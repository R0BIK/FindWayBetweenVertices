Міністерство освіти і науки України
Національний технічний університет України «Київський політехнічний
інститут імені Ігоря Сікорського»
Факультет інформатики та обчислювальної техніки

Кафедра інформатики та програмної інженерії


Звіт

з лабораторної роботи № 4
з дисципліни
«Алгоритми та структури даних. Частина 2. Структури даних»

«Метод швидкого сортування»





 
Виконав(ла) 


Перевірив


ІП-33 Цапурда Є. Д.
(шифр, прізвище, ім'я, по батькові)
	
Соколовський В. В
(прізвище, ім'я, по батькові)

 



Київ 2024
Постановка задачі:
Згідно варіанту, розробити та записати алгоритм задачі на графах за допомогою псевдокоду (чи іншого способу за вибором). Виконати програмну реалізацію алгоритму на будь-якій мові програмування для довільного графа, передбачити введення розмірності графа та введення даних графа вручну чи випадковим чином. Для самостійно обраного графа (розмірності не менше 9 вершин) розв’язати задану за варіантом задачу вручну. Зробити узагальнений висновок з лабораторної роботи, у якому порівняти програмне та ручне розв’язання задачі.

29	Пошук найкоротшого шляху між парою вершин	Дейкстри	Орієнтований	Матриця вагів

Псевдокод алгоритму:
1.  start ← Input of Integer
2.  current ← start - 1
3.  
4.  inf ← MaxValue
5.  distance ← List of Integers
6.  visited ← List of Booleans
7.  
8.  for i from 0 to n - 1
9.      do if i = current
10.          then distance.Add(0)
11.          else distance.Add(inf)
12.          visited.Add(false)
13.  
14. for j from 0 to n - 1
15.     do for i from 0 to n - 1
16.         do if weightMatrix[current][i] ≠ 0 and not visited[i]
17.             then if distance[i] > distance[current] + weightMatrix[current][i]
18.                 then distance[i] ← distance[current] + weightMatrix[current][i]
19.     visited[current] ← true
20.     current ← FindMinVertex()
21.  
22. function FindMinVertex()
23.     min ← inf
24.     minIndex ← 0
25.     
26.     for i from 0 to n - 1
27.         do if distance[i] < min and not visited[i]
28.             then minIndex ← i
29.                  min ← distance[i]
30.             
31.     return minIndex

Код програми (C#): 

List<List<int>> weightMatrix = new List<List<int>>();

Console.WriteLine("Вітаю в програмі пошуку найкоротшого шляху між парою вершин графа\n" +
                  "Оберіть метод задання матриці вагів\n" +
                  "1. Ввести самостійно\n" +
                  "2. Сгенерувати");

int method = int.Parse(Console.ReadLine());

Console.WriteLine("Введіть кількість (вершин) елементів матриці, мінімум 2:");
int n = int.Parse(Console.ReadLine());
if (n < 2)
{
    Console.WriteLine("Помилка");
    return;
}

if (method == 1)
    GetMatrix();
else if (method == 2)
    GenerateMatrix();
else
{
    Console.WriteLine("Помилка!");
}

Console.Clear();
Console.WriteLine("Введена матриця:\n");
WriteCurrentMatrix();

Console.WriteLine("\nВведіть номер початкової вершини: ");
int start = int.Parse(Console.ReadLine());
int current = start - 1;

int inf = Int32.MaxValue;
List<int> distance = new List<int>();
List<bool> visited = new List<bool>();

Dijkstra();
PrintResult();

void PrintResult()
{
    Console.WriteLine($"\nВідстань з вершини {start} до вершини:");

    for (int i = 0; i < n; ++i)
    {
        if (i != start - 1)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write(i + 1);
            Console.ResetColor();
            if (distance[i] >= inf)
                Console.Write(" - Дістатися неможливо\n");
            else
            {
                Console.Write($" - {distance[i]}\n");
            }
        }
    }
}

void Dijkstra()
{
    for (int i = 0; i < n; ++i)
    {
        if (i == current)
            distance.Add(0);
        else
        {
            distance.Add(inf);
        }
        visited.Add(false);
    }

    for (int j = 0; j < n; ++j)
    {
        for (int i = 0; i < n; ++i)
        {
            if (weightMatrix[current][i] != 0 && !visited[i])
            {
                if (distance[i] > distance[current] + weightMatrix[current][i])
                    distance[i] = distance[current] + weightMatrix[current][i];
            }
        }

        visited[current] = true;
        current = FindMinVertex();
    }
}

int FindMinVertex()
{
    int min = inf;
    int minIndex = 0;
    
    for (int i = 0; i < n; ++i)
    {
        if (distance[i] < min && !visited[i])
        {
            minIndex = i;
            min = distance[i];
        }
        
    }

    return minIndex;
}

void GetMatrix()
{
    Console.WriteLine("Почніть вводити елементи матриці:\n");
    for (int i = 0; i < n; ++i)
    {
        List<int> list = new List<int>();
        
        for (int j = 0; j < n; ++j)
        {
            Console.Clear();
            WriteCurrentMatrix();
            WriteCurrList(list);
            list.Add(Int32.Parse(Console.ReadLine()));
        }

        weightMatrix.Add(list);
    }
}

void WriteCurrList(List<int> list)
{
    if (list.Count == 0)
        return;
    for (int i = 0; i < list.Count; ++i)
    {
        Console.Write(list[i]);
        Console.Write("\t");
    }
}

void WriteCurrentMatrix()
{
    int matrixSize = weightMatrix.Count;
    if (matrixSize != 0)
    {
        int listSize = weightMatrix[matrixSize - 1].Count;
        if (listSize < n)
            --matrixSize;
    }
    
    for (int i = -1; i < matrixSize; ++i)
    {
        if (matrixSize == n && i != -1)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write(i + 1 + "\t");
            Console.ResetColor();
        }
        for (int j = 0; j < n; ++j)
        {
            if (i == -1)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.Write($"\t{j + 1}");
                Console.ResetColor();
            }
            else
            {
                Console.Write(weightMatrix[i][j]);
                Console.Write("\t");
            }
        }
        if (i < matrixSize)
            Console.Write("\n");
        if (matrixSize < n)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write(i + 2 + "\t");
            Console.ResetColor();
        }
    }
}

void GenerateMatrix()
{
    Random random = new Random();
    for (int i = 0; i < n; ++i)
    {
        List<int> list = new List<int>();

        for (int j = 0; j < n; ++j)
        {
            int g = random.Next(-n, n);
            if (g < 0)
                list.Add(0);
            else
            {
                list.Add(g);
            }
        }
        
        weightMatrix.Add(list);
    }
}

Робота програми:
Консоль програми:
 
Рис. 1. Консоль після запуску програми
 
Рис. 2. Обрано генерація матриці.
 
Рис. 3. Результат роботи програми
 
Рис. 4. Граф

Розрахунок складності та аналіз алгоритму:
Складність алгоритму Дейкстри залежить від способу зберігання безлічі невідвіданих вершин та способу оновлення міток. Позначимо через n кількість вершин, а через m  — кількість ребер у графі G . У найпростішому випадку, коли для пошуку вершини з мінімальним distance[v] проглядається все безліч вершин, а для зберігання величин distance використовується масив, час роботи алгоритму є θ(n^2). Основний цикл виконується порядку n разів, у кожному їх знаходження мінімуму витрачається порядку n операцій. На цикли по сусідах кожної відвідуваної вершини витрачається кількість операцій, пропорційне кількості ребер m (оскільки кожне ребро зустрічається у цих циклах рівно двічі і потребує константне число операцій). Таким чином, загальний час роботи алгоритму θ(n^2+m), але так як m≤n(n-1), воно складає θ(n^2).

Приклад роботи в ручному режимі:
 
Рис. 5. Матриця вагів графу.
 
Рис. 6. Граф з 9 вершинами.

Вершина від якої будемо рахувати відстань – 1. Робимо її активною та починаємо виконувати алгоритм.
 
Рис. 7.1 Активна вершина – 1.

 
Рис. 7.2 Таблиця відстаней



 
Рис. 8.1. Записуємо відстані до доступних вершин якщо вони менші за наявні записи

 
Рис. 8.2. Виділяємо 1 вершину як відвідану.


 
Рис. 9.1 Виділяємо вершину до якої відстань менше, як активну.

 
Рис. 9.2. Рахуємо відстань до доступних не відвіданих вершин.

 
Рис. 10.1 Виділяємо 2 вершину як відвідану, а 3, бо найменша відстань, як активну.

 
Рис. 10.2. Рахуємо відстань до доступних не відвіданих вершин.


 
Рис. 11.1. 3 вершина – відвідана. 5 – активна.


 
Рис. 11.2 Рахуємо відстань до доступних не відвіданих вершин. До вершини 6 відстань буде 7 + 9 = 16, але в нашому масиві відстань до 6 = 7 і це менше, тому не змінюємо запис.

 
Рис. 12.1. 5 – відвідана. 6 – активна.



 
Рис. 12.2. Рахуємо відстань до доступних не відвіданих вершин.

 
Рис. 13.1 6 – відвідана. 7 – активна.

 
13.2. Рахуємо відстань до доступних не відвіданих вершин.

 
Рис. 14.1. 7 – відвідана. 8 – активна.

 
Рис. 14.2. Рахуємо відстань до доступних не відвіданих вершин.





 
Рис. 15.1. 8 – відвідана. 4 – активна.
 
Рис. 15.2. Рахуємо відстань до доступних не відвіданих вершин.
 
Рис. 16.1. 4 – відвідана. 9 – активна.

 
Рис. 16.2. Рахуємо відстань до доступних не відвіданих вершин.
 
Рис. 17.1. Всі вершини – відвідані.


 
Рис. 17.2. Рядок №9 – остання версія масиву відстаней. Він і є результатом. Якщо там лишилась нескінченість – вершина не досяжна. Приклад на рис. 3 – 4.
 
Рис. 18.1. Самостійно вводимо матрицю вагів.
 
Рис. 18.2. Починаємо ввід.
 
Рис. 18.3. Ввід закінчено. Натискаємо Enter/Return
 
Рис. 18.4. Результат роботи програми.
 
Рис. 18.5. Перевірка ручної та програмної реалізацій алгоритму. 

Висновок:
Під час виконання цієї лабораторної роботи ми розробили програмну реалізацію пошуку найкоротшого шляху між парою вершин у графі. Для вирішення цієї задачі ми використовували алгоритм Дейкстри, який дозволяє знайти найкоротший шлях між вершинами у вагованому орієнтованому графі.

Програмна реалізація алгоритму була проведена на мові програмування C#, з врахуванням введення розмірності графа та введення даних графа вручну або випадкова генерація. Для цього було використано матрицю вагів, де кожен елемент матриці представляє собою вагу ребра між відповідними вершинами.

Також було зроблено покрокові розрахунки відповідно алгоритму Дейкстри в ручному режимі. Результати ручного обрахунку збіглися з програмним варіантом, що підтверджує коректність роботи алгоритму.

Ручне розв'язання дозволило нам крок за кроком простежити, як саме працює алгоритм Дейкстри, та глибше зрозуміти його принципи. Ми могли контролювати вхідні дані та кроки обчислення, що дало можливість перевірити правильність роботи алгоритму та отриманих результатів.

Щодо часової складності алгоритму Дейкстри, вона залежить від кількості вершин і ребер у графі. У найгіршому випадку, коли граф має n вершин і 𝐸 ребер, часова складність алгоритму Дейкстри складає θ(n^2). Однак, застосування покращених версій алгоритму Дейкстри, таких як алгоритм з використанням черги з пріоритетами, може значно зменшити часову складність до θ((n+E)  log⁡n), що дозволяє використовувати його у великих графах з більшою ефективністю.
![image](https://github.com/R0BIK/FindWayBetweenVertices/assets/99051328/eba8eeeb-c83c-4c75-959b-bfb37b8f41fd)
